import json
import pytest
import shutil
import subprocess
import importlib.util
from pathlib import Path
import sys
from unittest.mock import patch, MagicMock, Mock
from file2ai import (
    parse_args,
    is_text_file,
    validate_github_url,
    export_files_to_json,
    export_files_to_single_file,
    parse_github_url,
    build_auth_url,
    prepare_exports_dir,
    clone_and_export,
    local_export,
    check_docx_support,
    install_docx_support,
    check_excel_support,
    install_excel_support,
    check_pptx_support,
    install_pptx_support,
    check_html_support,
    install_html_support,
    convert_document,
    setup_logging,
)


def test_parse_args_repo(monkeypatch):
    """Test argument parsing with repo URL."""
    monkeypatch.setattr(
        sys, "argv", ["file2ai.py", "--repo-url", "https://github.com/owner/repo.git"]
    )
    args = parse_args()
    assert args.repo_url == "https://github.com/owner/repo.git"
    assert args.local_dir is None


def test_parse_args_local(monkeypatch):
    """Test argument parsing with local directory."""
    monkeypatch.setattr(sys, "argv", ["file2ai.py", "--local-dir", "/path/to/dir"])
    args = parse_args()
    assert args.local_dir == "/path/to/dir"
    assert args.repo_url is None


def test_parse_args_interactive(monkeypatch):
    """Test argument parsing with interactive input."""
    inputs = ["https://github.com/owner/repo.git", ""]
    input_iter = iter(inputs)
    monkeypatch.setattr("builtins.input", lambda _: next(input_iter))
    monkeypatch.setattr("sys.argv", ["file2ai.py"])
    args = parse_args()
    assert args.repo_url == "https://github.com/owner/repo.git"
    assert args.local_dir is None


def test_is_text_file(tmp_path):
    """Test text file detection."""
    # Test Python file
    py_file = tmp_path / "example.py"
    py_file.write_text("print('Hello')")
    assert is_text_file(py_file) is True

    # Test binary file
    bin_file = tmp_path / "example.bin"
    bin_file.write_bytes(b"\x00\x01\x02\x03")
    assert is_text_file(bin_file) is False


def test_validate_github_url():
    """Test GitHub URL validation."""
    assert validate_github_url("https://github.com/owner/repo") is True
    assert validate_github_url("https://github.com/owner/repo.git") is True
    assert validate_github_url("not_a_url") is False
    assert validate_github_url("") is False


def test_text_export_error_handling(tmp_path, caplog):
    """Test text export error handling with invalid files."""
    import logging
    from file2ai import setup_logging

    setup_logging()
    caplog.set_level(logging.DEBUG)

    # Create a sample directory with a binary file
    sample_dir = tmp_path / "error_project"
    sample_dir.mkdir()
    binary_file = sample_dir / "binary.dat"
    binary_file.write_bytes(b"\x00\x01\x02\x03")

    # Create output file
    output_file = tmp_path / "error_export.txt"

    # Export to text
    export_files_to_single_file(None, "error-test", sample_dir, output_file, skip_commit_info=True)

    # Verify file exists but contains no binary file content
    assert output_file.exists()
    content = output_file.read_text()
    assert "Generated by file2ai" in content
    assert "Directory Structure:" in content
    assert "binary.dat" not in content  # Binary file should be ignored

    # Check if binary file was logged as skipped
    assert f"Skipped binary file: {binary_file}" in caplog.text


def test_text_export_basic(tmp_path, caplog):
    """Test basic text export functionality without git repo."""
    # Verify logging is initialized
    from file2ai import setup_logging

    setup_logging()
    # Create a sample file
    sample_dir = tmp_path / "sample_project"
    sample_dir.mkdir()
    sample_file = sample_dir / "hello.txt"
    sample_file.write_text("Hello, World!")

    # Create output file
    output_file = tmp_path / "output.txt"

    # Export to text
    export_files_to_single_file(None, "test-export", sample_dir, output_file, skip_commit_info=True)

    # Verify text structure
    content = output_file.read_text()
    assert "Generated by file2ai" in content
    assert "Directory Structure:" in content
    assert "hello.txt" in content
    assert "Hello, World!" in content
    assert "Repository: test-export" in content


@pytest.mark.parametrize("format_arg", ["text", "json"])
def test_format_argument(format_arg, monkeypatch):
    """Test that --format argument is correctly parsed."""
    monkeypatch.setattr(sys, "argv", ["file2ai.py", "--local-dir", ".", "--format", format_arg])
    args = parse_args()
    assert args.format == format_arg


def test_text_export_with_git(tmp_path, caplog):
    """Test text export with mocked git repository."""
    # Verify logging is initialized
    from file2ai import setup_logging

    setup_logging()
    # Create a sample file
    sample_dir = tmp_path / "git_project"
    sample_dir.mkdir()
    sample_file = sample_dir / "code.py"
    sample_file.write_text("print('Hello Git')")

    # Mock Git objects
    mock_commit = MagicMock()
    mock_commit.message = "Initial commit"
    mock_commit.author.name = "Test Author"
    mock_commit.committed_datetime.isoformat.return_value = "2023-01-01T00:00:00"

    mock_repo = MagicMock()
    mock_repo.iter_commits.return_value = iter([mock_commit])

    # Create output file
    output_file = tmp_path / "repo_export.txt"

    # Export to text
    export_files_to_single_file(mock_repo, "git-project", sample_dir, output_file)

    # Verify text structure
    content = output_file.read_text()
    assert "Generated by file2ai" in content
    assert "Directory Structure:" in content
    assert "code.py" in content
    assert "print('Hello Git')" in content
    assert "Repository: git-project" in content
    assert "Initial commit" in content
    assert "Test Author" in content
    assert "2023-01-01" in content


def test_parse_github_url():
    """Test GitHub URL parsing and validation."""
    # Test basic URL without subdirectory processing
    base_url, branch, subdir = parse_github_url("https://github.com/owner/repo.git", use_subdirectory=False)
    assert base_url == "https://github.com/owner/repo.git"
    assert branch is None
    assert subdir is None

    # Test URL without .git (should add it)
    base_url, branch, subdir = parse_github_url("https://github.com/owner/repo", use_subdirectory=False)
    assert base_url == "https://github.com/owner/repo.git"
    assert branch is None
    assert subdir is None

    # Test deep URL with branch and path, without subdirectory processing
    base_url, branch, subdir = parse_github_url(
        "https://github.com/owner/repo/tree/main/path/to/dir",
        use_subdirectory=False
    )
    assert base_url == "https://github.com/owner/repo.git"
    assert branch == "main"
    assert subdir is None

    # Test deep URL with branch and path, with subdirectory processing
    base_url, branch, subdir = parse_github_url(
        "https://github.com/owner/repo/tree/feature/nested/path",
        use_subdirectory=True
    )
    assert base_url == "https://github.com/owner/repo.git"
    assert branch == "feature"
    assert subdir == "nested/path"

    # Test URLs with invalid suffixes (should be removed)
    base_url, branch, subdir = parse_github_url("https://github.com/owner/repo/pulls")
    assert base_url == "https://github.com/owner/repo.git"
    assert branch is None
    assert subdir is None

    base_url, branch, subdir = parse_github_url("https://github.com/owner/repo/issues")
    assert base_url == "https://github.com/owner/repo.git"
    assert branch is None
    assert subdir is None

    base_url, branch, subdir = parse_github_url("https://github.com/owner/repo/actions")
    assert base_url == "https://github.com/owner/repo.git"
    assert branch is None
    assert subdir is None

    # Test invalid URL format (should still exit)
    with pytest.raises(SystemExit):
        parse_github_url("not_a_url")

def test_deep_url_handling():
    """Test handling of deep GitHub URLs with subdirectories."""
    # Test deep URL with subdirectory flag before URL
    with patch('sys.argv', [
        'file2ai.py',
        '--repo-url-sub',
        'https://github.com/owner/repo/tree/main/path/to/dir'
    ]):
        args = parse_args()
        assert args.repo_url == "https://github.com/owner/repo/tree/main/path/to/dir"
        assert args.repo_url_sub is True

    # Test deep URL without subdirectory flag
    with patch('sys.argv', [
        'file2ai.py',
        '--repo-url',
        'https://github.com/owner/repo/tree/main/path/to/dir'
    ]):
        args = parse_args()
        assert args.repo_url == "https://github.com/owner/repo/tree/main/path/to/dir"
        assert args.repo_url_sub is False

    # Test with multiple flags before URL
    with patch('sys.argv', [
        'file2ai.py',
        '--branch', 'dev',
        '--repo-url-sub',
        'https://github.com/owner/repo/tree/main/path/to/dir'
    ]):
        args = parse_args()
        assert args.repo_url == "https://github.com/owner/repo/tree/main/path/to/dir"
        assert args.repo_url_sub is True
        assert args.branch == 'dev'


def test_build_auth_url():
    """Test building authenticated GitHub URL."""
    base_url = "https://github.com/owner/repo.git"
    token = "ghp_123456789"
    auth_url = build_auth_url(base_url, token)
    assert auth_url == "https://ghp_123456789@github.com/owner/repo.git"


def test_prepare_exports_dir(tmp_path):
    """Test exports directory preparation."""
    with patch("file2ai.EXPORTS_DIR", str(tmp_path / "exports")):
        exports_dir = prepare_exports_dir()
        assert exports_dir.exists()
        assert exports_dir.is_dir()


def test_clone_and_export_basic(tmp_path, caplog):
    """Test basic repository cloning and export with branch and subdirectory handling."""
    import logging
    from file2ai import setup_logging
    import subprocess

    setup_logging()
    logger = logging.getLogger("file2ai")
    caplog.set_level(logging.INFO)

    # Create a temporary git repository
    repo_dir = tmp_path / "repo"
    repo_dir.mkdir()
    
    # Create main test file
    (repo_dir / "test.py").write_text("print('test')")
    
    # Create subdirectory with content
    subdir = repo_dir / "subdir"
    subdir.mkdir()
    (subdir / "subfile.py").write_text("print('subdir test')")

    # Initialize git repo
    subprocess.run(["git", "init", "--initial-branch=main"], cwd=repo_dir, check=True, capture_output=True)
    subprocess.run(
        ["git", "config", "user.name", "test"], cwd=repo_dir, check=True, capture_output=True
    )
    subprocess.run(
        ["git", "config", "user.email", "test@test.com"],
        cwd=repo_dir,
        check=True,
        capture_output=True,
    )
    subprocess.run(["git", "add", "."], cwd=repo_dir, check=True, capture_output=True)
    subprocess.run(
        ["git", "commit", "-m", "Initial commit"], cwd=repo_dir, check=True, capture_output=True
    )
    
    # Create and switch to test branch
    subprocess.run(["git", "checkout", "-b", "test-branch"], cwd=repo_dir, check=True, capture_output=True)
    (repo_dir / "branch-file.py").write_text("print('branch test')")
    subprocess.run(["git", "add", "."], cwd=repo_dir, check=True, capture_output=True)
    subprocess.run(
        ["git", "commit", "-m", "Branch commit"], cwd=repo_dir, check=True, capture_output=True
    )
    
    # Switch back to main
    subprocess.run(["git", "checkout", "main"], cwd=repo_dir, check=True, capture_output=True)
    
    # Ensure .git directory is copied properly
    subprocess.run(["chmod", "-R", "755", repo_dir], check=True, capture_output=True)

    # Create exports directory
    exports_dir = tmp_path / "exports"
    exports_dir.mkdir()

    # Mock subprocess.run for git clone to use our temp repo
    def mock_clone(*args, **kwargs):
        nonlocal logger
        cmd = args[0] if args else kwargs.get("args", [])
        if cmd[0] == "git" and cmd[1] == "clone":
            # Copy our temp repo instead of actually cloning
            target = Path(cmd[-1])
            # Use shutil.copytree for reliable directory copying
            import shutil
            if target.exists():
                shutil.rmtree(target)
            shutil.copytree(repo_dir, target, symlinks=True)
            # Verify the .git directory exists
            if not (target / ".git").exists():
                logger.error(f".git directory not found in {target}")
                raise RuntimeError("Git repository not properly copied")
            logger.debug(f"Repository copied to {target}, .git directory verified")
        return MagicMock(returncode=0)

    with patch("subprocess.run", side_effect=mock_clone):
        # Create args namespace
        args = MagicMock()
        args.repo_url = "https://github.com/owner/repo.git"
        args.branch = None
        args.token = None
        args.format = "text"
        args.output_file = "test_export.txt"
        args.skip_remove = False
        args.subdir = None  # Explicitly set subdir to None
        args.repo_url_sub = None  # Explicitly set repo_url_sub to None

        # Test with default branch
        with patch("file2ai.EXPORTS_DIR", str(exports_dir)):
            clone_and_export(args)
            assert "Using default branch" in caplog.text

        # Test with explicit branch
        args.branch = "test-branch"
        with patch("file2ai.EXPORTS_DIR", str(exports_dir)):
            clone_and_export(args)
            assert f"Checked out branch: {args.branch}" in caplog.text

        # Test with subdirectory
        args.branch = None
        args.subdir = "subdir"
        with patch("file2ai.EXPORTS_DIR", str(exports_dir)):
            clone_and_export(args)
            assert "Exporting from subdirectory: subdir" in caplog.text

        # Test with invalid subdirectory
        args.subdir = "nonexistent"
        with patch("file2ai.EXPORTS_DIR", str(exports_dir)):
            with pytest.raises(SystemExit):
                clone_and_export(args)
            assert "Subdirectory nonexistent does not exist" in caplog.text

        # Reset to default for final verification
        args.subdir = None
        args.branch = None

        # Patch exports directory
        with patch("file2ai.EXPORTS_DIR", str(exports_dir)):
            clone_and_export(args)

        # Verify export file was created
        assert (exports_dir / "test_export.txt").exists()


def test_local_export(tmp_path, caplog):
    """Test local directory export."""
    import logging
    from file2ai import setup_logging

    setup_logging()
    caplog.set_level(logging.INFO)

    # Create a sample directory with files
    local_dir = tmp_path / "local_project"
    local_dir.mkdir()
    (local_dir / "test.py").write_text("print('test')")

    # Create exports directory
    exports_dir = tmp_path / "exports"
    exports_dir.mkdir()

    # Create args namespace
    args = MagicMock()
    args.local_dir = str(local_dir)
    args.format = "text"
    args.output_file = "test_export.txt"
    args.skip_remove = False

    # Patch exports directory and ensure it exists
    with patch("file2ai.EXPORTS_DIR", str(exports_dir)):
        # Add debug logging
        logger = logging.getLogger("file2ai")
        logger.setLevel(logging.DEBUG)
        local_export(args)
        
        # Log the expected output path
        expected_path = exports_dir / "test_export.txt"
        logger.debug(f"Expected output path: {expected_path}")
        logger.debug(f"Directory contents: {list(exports_dir.iterdir())}")
        
        # Wait a moment for file operations to complete
        import time
        time.sleep(0.1)

    # Verify export file was created
    assert (exports_dir / "test_export.txt").exists()

    # Verify export was logged
    assert any("Starting export of local directory" in record.message for record in caplog.records)


def test_branch_handling(tmp_path, caplog):
    """Test branch checkout behavior."""
    from argparse import Namespace
    import logging
    import subprocess
    
    caplog.set_level(logging.INFO)
    
    # Create a test repository
    repo_dir = tmp_path / "repo"
    repo_dir.mkdir()
    (repo_dir / "test.py").write_text("print('test')")
    
    # Initialize git repo
    subprocess.run(["git", "init", "--initial-branch=main"], cwd=repo_dir, check=True, capture_output=True)
    subprocess.run(["git", "config", "user.name", "test"], cwd=repo_dir, check=True, capture_output=True)
    subprocess.run(["git", "config", "user.email", "test@test.com"], cwd=repo_dir, check=True, capture_output=True)
    subprocess.run(["git", "add", "."], cwd=repo_dir, check=True, capture_output=True)
    subprocess.run(["git", "commit", "-m", "Initial commit"], cwd=repo_dir, check=True, capture_output=True)
    
    # Create and switch to test branch
    subprocess.run(["git", "checkout", "-b", "test-branch"], cwd=repo_dir, check=True, capture_output=True)
    (repo_dir / "branch-file.py").write_text("print('branch test')")
    subprocess.run(["git", "add", "."], cwd=repo_dir, check=True, capture_output=True)
    subprocess.run(["git", "commit", "-m", "Branch commit"], cwd=repo_dir, check=True, capture_output=True)
    
    # Switch back to main
    subprocess.run(["git", "checkout", "main"], cwd=repo_dir, check=True, capture_output=True)
    
    # Create exports directory
    exports_dir = tmp_path / "exports"
    exports_dir.mkdir()
    
    # Mock subprocess.run for git clone
    def mock_clone(*args, **kwargs):
        cmd = args[0] if args else kwargs.get("args", [])
        if cmd[0] == "git" and cmd[1] == "clone":
            target = Path(cmd[-1])
            import shutil
            if target.exists():
                shutil.rmtree(target)
            shutil.copytree(repo_dir, target, symlinks=True)
        return MagicMock(returncode=0)
    
    
    with patch("subprocess.run", side_effect=mock_clone):
        # Test default branch with URL only
        with patch('sys.argv', [
            'file2ai.py',
            '--repo-url',
            'https://github.com/owner/repo.git'
        ]):
            args = parse_args()
            with patch("file2ai.EXPORTS_DIR", str(exports_dir)):
                clone_and_export(args)
                assert "Using default branch" in caplog.text
        
        # Test with branch flag before URL
        with patch('sys.argv', [
            'file2ai.py',
            '--branch', 'test-branch',
            '--repo-url',
            'https://github.com/owner/repo.git'
        ]):
            args = parse_args()
            with patch("file2ai.EXPORTS_DIR", str(exports_dir)):
                clone_and_export(args)
                assert "Checked out branch: test-branch" in caplog.text
        
        # Test with multiple flags before URL
        with patch('sys.argv', [
            'file2ai.py',
            '--branch', 'test-branch',
            '--skip-remove',
            '--repo-url',
            'https://github.com/owner/repo.git'
        ]):
            args = parse_args()
            with patch("file2ai.EXPORTS_DIR", str(exports_dir)):
                clone_and_export(args)
                assert "Checked out branch: test-branch" in caplog.text


def test_subdirectory_handling(tmp_path, caplog):
    """Test subdirectory export behavior."""
    from argparse import Namespace
    import logging
    import subprocess
    
    caplog.set_level(logging.INFO)
    
    # Create test repository
    repo_dir = tmp_path / "repo"
    repo_dir.mkdir()
    
    # Create main directory content
    (repo_dir / "main.py").write_text("print('main')")
    
    # Create subdirectory content
    subdir = repo_dir / "subdir"
    subdir.mkdir()
    (subdir / "sub.py").write_text("print('sub')")
    
    # Initialize git repo
    subprocess.run(["git", "init", "--initial-branch=main"], cwd=repo_dir, check=True, capture_output=True)
    subprocess.run(["git", "config", "user.name", "test"], cwd=repo_dir, check=True, capture_output=True)
    subprocess.run(["git", "config", "user.email", "test@test.com"], cwd=repo_dir, check=True, capture_output=True)
    subprocess.run(["git", "add", "."], cwd=repo_dir, check=True, capture_output=True)
    subprocess.run(["git", "commit", "-m", "Initial commit"], cwd=repo_dir, check=True, capture_output=True)
    
    # Create exports directory
    exports_dir = tmp_path / "exports"
    exports_dir.mkdir()
    
    # Mock subprocess.run for git clone
    def mock_clone(*args, **kwargs):
        cmd = args[0] if args else kwargs.get("args", [])
        if cmd[0] == "git" and cmd[1] == "clone":
            target = Path(cmd[-1])
            import shutil
            if target.exists():
                shutil.rmtree(target)
            shutil.copytree(repo_dir, target, symlinks=True)
        return MagicMock(returncode=0)
    
    with patch("subprocess.run", side_effect=mock_clone):
        # Test with --repo-url-sub flag before deep URL
        with patch('sys.argv', [
            'file2ai.py',
            '--repo-url-sub',
            'https://github.com/owner/repo/tree/main/subdir'
        ]):
            args = parse_args()
            with patch("file2ai.EXPORTS_DIR", str(exports_dir)):
                clone_and_export(args)
                assert "Exporting from subdirectory: subdir" in caplog.text
        
        # Test with invalid subdirectory
        with patch('sys.argv', [
            'file2ai.py',
            '--repo-url-sub',
            'https://github.com/owner/repo/tree/main/nonexistent'
        ]):
            args = parse_args()
            with patch("file2ai.EXPORTS_DIR", str(exports_dir)):
                with pytest.raises(SystemExit):
                    clone_and_export(args)
                assert "Subdirectory nonexistent does not exist" in caplog.text
        
        # Test without subdirectory flag (should export from root)
        with patch('sys.argv', [
            'file2ai.py',
            '--repo-url',
            'https://github.com/owner/repo/tree/main/subdir'
        ]):
            args = parse_args()
            with patch("file2ai.EXPORTS_DIR", str(exports_dir)):
                clone_and_export(args)
                assert "Exporting from repository root" in caplog.text
        
        # Test with multiple flags before URL
        with patch('sys.argv', [
            'file2ai.py',
            '--branch', 'main',
            '--skip-remove',
            '--repo-url-sub',
            'https://github.com/owner/repo/tree/main/subdir'
        ]):
            args = parse_args()
            with patch("file2ai.EXPORTS_DIR", str(exports_dir)):
                clone_and_export(args)
                assert "Exporting from subdirectory: subdir" in caplog.text
                assert "Checked out branch: main" in caplog.text


def test_logging_setup(tmp_path, caplog):
    """Test logging setup and file handling."""
    import logging
    from file2ai import setup_logging, LOGS_DIR

    # Configure caplog
    caplog.set_level(logging.INFO)

    # Setup logging
    setup_logging()

    # Verify logs directory was created
    log_dir = Path(LOGS_DIR)
    assert log_dir.exists()
    assert log_dir.is_dir()

    # Test logging output
    logger = logging.getLogger("file2ai")
    test_message = "Test log message"
    logger.info(test_message)

    # Check if message was logged
    assert any(record.message == test_message for record in caplog.records)


def test_docx_dependency_management(monkeypatch, caplog):
    """Test python-docx dependency checking and installation."""
    import logging
    from importlib.util import find_spec

    # Mock importlib.util.find_spec to simulate missing docx
    def mock_find_spec(name):
        return None if name == "docx" else find_spec(name)
    
    monkeypatch.setattr(importlib.util, "find_spec", mock_find_spec)
    
    # Mock successful pip install
    def mock_check_call(*args, **kwargs):
        return 0
    monkeypatch.setattr(subprocess, "check_call", mock_check_call)
    
    # Test dependency checking
    assert check_docx_support() is False
    
    # Test installation
    assert install_docx_support() is True


def test_word_to_text_conversion(tmp_path, caplog, monkeypatch):
    """Test Word document to text conversion."""
    import logging

    # Mock Document class
    class MockDocument:
        def __init__(self, file_path=None):
            self.paragraphs = [
                Mock(text="Hello, World!"),
                Mock(text="This is a test document."),
            ]
            self.tables = [Mock()]
            self.tables[0].rows = [
                Mock(cells=[Mock(text="Cell 1"), Mock(text="Cell 2")]),
                Mock(cells=[Mock(text="Cell 3"), Mock(text="Cell 4")])
            ]
        
        def save(self, path):
            path.write_text("Mock DOCX content")

    monkeypatch.setattr("docx.Document", MockDocument)
    setup_logging()
    caplog.set_level(logging.INFO)

    # Create a test Word document using our mock
    test_doc = tmp_path / "test.docx"
    mock_doc = MockDocument()
    mock_doc.save(test_doc)
    
    # Set up arguments for conversion
    with patch('sys.argv', ['file2ai.py', 'convert', '--input', str(test_doc), '--format', 'text']):
        args = parse_args()
        convert_document(args)
    
    # Check output file
    exports_dir = Path("exports")
    output_files = list(exports_dir.glob("test*.text"))
    assert len(output_files) == 1
    output_content = output_files[0].read_text()
    
    # Verify content
    assert "Hello, World!" in output_content
    assert "This is a test document." in output_content
    assert "Cell 1 | Cell 2" in output_content
    assert "Cell 3 | Cell 4" in output_content
    
    # Clean up
    shutil.rmtree(exports_dir)




def test_word_conversion_errors(tmp_path, caplog, monkeypatch):
    """Test error handling in Word document conversion."""
    import logging
    from unittest.mock import patch

    # Mock Document class
    class MockDocument:
        def __init__(self, file_path=None):
            raise ImportError("Failed to import python-docx")
        
        def save(self, path):
            raise ImportError("Failed to save document")

    monkeypatch.setattr("docx.Document", MockDocument)
    setup_logging()
    caplog.set_level(logging.ERROR)

    # Create a test Word document
    test_doc = tmp_path / "test.docx"
    test_doc.write_bytes(b"Mock DOCX content")

    # Test conversion with import error
    with pytest.raises(SystemExit):
        with patch('sys.argv', ['file2ai.py', 'convert', '--input', str(test_doc), '--format', 'text']):
            args = parse_args()
            convert_document(args)

    assert "Error converting Word document" in caplog.text


def test_excel_dependency_management(monkeypatch, caplog):
    """Test openpyxl dependency checking and installation."""
    import logging
    from importlib.util import find_spec

    # Mock importlib.util.find_spec to simulate missing openpyxl
    def mock_find_spec(name):
        return None if name == "openpyxl" else find_spec(name)
    
    monkeypatch.setattr(importlib.util, "find_spec", mock_find_spec)
    
    # Mock successful pip install
    def mock_check_call(*args, **kwargs):
        return 0
    monkeypatch.setattr(subprocess, "check_call", mock_check_call)
    
    # Test dependency checking
    assert check_excel_support() is False
    
    # Test installation
    assert install_excel_support() is True


def test_excel_to_text_conversion(tmp_path, caplog, monkeypatch):
    """Test Excel document to text conversion."""
    import logging
    from unittest.mock import Mock, patch

    # Mock Workbook class
    class MockWorkbook:
        def __init__(self):
            self.active = Mock()
            self.worksheets = [self.active]
            self.active.title = "Sheet1"
            mock_rows = [
                [Mock(value="Name"), Mock(value="Age"), Mock(value="Notes")],
                [Mock(value="John Doe"), Mock(value="30"), Mock(value="Regular customer")],
                [Mock(value="Jane Smith"), Mock(value="25"), Mock(value="VIP, priority service")]
            ]
            self.active.rows = mock_rows
            self.active.iter_rows = Mock(return_value=mock_rows)

    def mock_load_workbook(file_path, data_only=False):
        return MockWorkbook()

    monkeypatch.setattr("openpyxl.load_workbook", mock_load_workbook)
    setup_logging()
    caplog.set_level(logging.INFO)

    # Create a test Excel document
    test_excel = tmp_path / "test.xlsx"
    test_excel.write_bytes(b"Mock Excel content")
    
    # Convert the document
    with patch('sys.argv', ['file2ai.py', 'convert', '--input', str(test_excel), '--format', 'text']):
        args = parse_args()
        convert_document(args)
    
    # Check output file
    exports_dir = Path("exports")
    output_files = list(exports_dir.glob("test*.text"))
    assert len(output_files) == 1
    output_content = output_files[0].read_text()
    
    # Verify content
    assert "Name" in output_content
    assert "John Doe" in output_content
    assert "Regular customer" in output_content
    
    # Clean up
    shutil.rmtree(exports_dir)


def test_excel_to_csv_conversion(tmp_path, caplog, monkeypatch):
    """Test Excel document to CSV conversion."""
    import logging
    from unittest.mock import Mock, patch

    # Mock Workbook class
    class MockWorkbook:
        def __init__(self):
            self.active = Mock()
            self.worksheets = [self.active]
            self.active.title = "Sheet1"
            self.active.rows = []
            self.active.iter_rows.return_value = [
                [Mock(value="Product"), Mock(value="Price")],
                [Mock(value="Widget"), Mock(value="99.99")],
                [Mock(value="Gadget"), Mock(value="149.99")]
            ]

    def mock_load_workbook(file_path, data_only=False):
        return MockWorkbook()

    monkeypatch.setattr("openpyxl.load_workbook", mock_load_workbook)
    setup_logging()
    caplog.set_level(logging.INFO)

    # Create a test Excel document
    test_excel = tmp_path / "test.xlsx"
    test_excel.write_bytes(b"Mock Excel content")
    
    # Convert the document
    with patch('sys.argv', ['file2ai.py', 'convert', '--input', str(test_excel), '--format', 'csv']):
        args = parse_args()
        convert_document(args)
    
    # Check output file
    exports_dir = Path("exports")
    output_files = list(exports_dir.glob("test*.csv"))
    assert len(output_files) == 1
    output_content = output_files[0].read_text()
    
    # Verify CSV content
    assert "Product,Price" in output_content
    assert "Widget,99.99" in output_content
    assert "Gadget,149.99" in output_content
    
    # Clean up
    shutil.rmtree(exports_dir)


def test_excel_conversion_errors(tmp_path, caplog, monkeypatch):
    """Test error handling in Excel document conversion."""
    import logging
    from unittest.mock import Mock, patch

    setup_logging()
    caplog.set_level(logging.ERROR)

    # Create a test Excel document
    test_excel = tmp_path / "test.xlsx"
    test_excel.write_bytes(b"Mock Excel content")

    # Test unsupported output format first (before import error mock)
    class MockWorkbook:
        def __init__(self):
            self.active = Mock()
            self.worksheets = [self.active]
            self.active.title = "Sheet1"

    def mock_load_workbook_success(file_path, data_only=False):
        return MockWorkbook()

    monkeypatch.setattr("openpyxl.load_workbook", mock_load_workbook_success)

    with patch('sys.argv', ['file2ai.py', 'convert', '--input', str(test_excel), '--format', 'pdf']):
        args = parse_args()
        with pytest.raises(SystemExit):
            convert_document(args)

    assert "Unsupported output format for Excel documents" in caplog.text
    caplog.clear()

    # Now test import error
    def mock_load_workbook_error(file_path, data_only=False):
        raise ImportError("Failed to import openpyxl")

    monkeypatch.setattr("openpyxl.load_workbook", mock_load_workbook_error)

    with pytest.raises(SystemExit):
        with patch('sys.argv', ['file2ai.py', 'convert', '--input', str(test_excel), '--format', 'csv']):
            args = parse_args()
            convert_document(args)

    assert "Error converting Excel document" in caplog.text
    caplog.clear()

    # Test non-existent file
    with patch('sys.argv', ['file2ai.py', 'convert', '--input', 'nonexistent.xlsx', '--format', 'text']):
        args = parse_args()
        with pytest.raises(SystemExit):
            convert_document(args)

    assert "Input file not found" in caplog.text


def test_pptx_dependency_management(monkeypatch, caplog):
    """Test python-pptx dependency checking and installation."""
    import logging
    from importlib.util import find_spec

    # Mock importlib.util.find_spec to simulate missing pptx
    def mock_find_spec(name):
        return None if name == "pptx" else find_spec(name)
    
    monkeypatch.setattr(importlib.util, "find_spec", mock_find_spec)
    
    # Mock successful pip install
    def mock_check_call(*args, **kwargs):
        return 0
    monkeypatch.setattr(subprocess, "check_call", mock_check_call)
    
    # Test dependency checking
    assert check_pptx_support() is False
    
    # Test installation
    assert install_pptx_support() is True


def test_ppt_to_text_conversion(tmp_path, caplog, monkeypatch):
    """Test PowerPoint document to text conversion."""
    import logging
    import sys
    from unittest.mock import Mock, patch, MagicMock

    # Mock Presentation class and pptx module
    class MockShape:
        def __init__(self, text=""):
            self.text = text

    class MockSlide:
        def __init__(self, texts):
            self.shapes = [MockShape(text) for text in texts]

    class MockPresentation:
        def __init__(self):
            self.slides = [
                MockSlide(["Title Slide", "Subtitle Text"]),
                MockSlide(["Content Slide", "• Bullet Point 1", "• Bullet Point 2"]),
                MockSlide(["Final Slide", "Thank You!"])
            ]

    # Mock the pptx module
    mock_pptx = Mock()
    mock_pptx.Presentation = lambda _: MockPresentation()
    monkeypatch.setattr("sys.modules", {"pptx": mock_pptx, **sys.modules})
    
    setup_logging()
    caplog.set_level(logging.INFO)

    # Create a test PowerPoint document
    test_ppt = tmp_path / "test.pptx"
    test_ppt.write_bytes(b"Mock PPT content")
    
    # Convert the document
    with patch('sys.argv', ['file2ai.py', 'convert', '--input', str(test_ppt), '--format', 'text']):
        args = parse_args()
        convert_document(args)
    
    # Check output file
    exports_dir = Path("exports")
    output_files = list(exports_dir.glob("test*.text"))
    assert len(output_files) == 1
    output_content = output_files[0].read_text()
    
    # Verify content
    assert "Slide 1:" in output_content
    assert "Title Slide" in output_content
    assert "Subtitle Text" in output_content
    assert "Slide 2:" in output_content
    assert "Content Slide" in output_content
    assert "Bullet Point 1" in output_content
    assert "Bullet Point 2" in output_content
    assert "Slide 3:" in output_content
    assert "Final Slide" in output_content
    assert "Thank You!" in output_content
    
    # Clean up
    shutil.rmtree(exports_dir)


def test_ppt_to_image_conversion(tmp_path, caplog, monkeypatch):
    """Test PowerPoint document to image conversion."""
    import logging
    import sys
    from unittest.mock import Mock, patch, MagicMock

    # Mock Presentation, Pillow, and pptx module
    class MockShape:
        def __init__(self, text=""):
            self.text = text

    class MockSlide:
        def __init__(self, texts):
            self.shapes = [MockShape(text) for text in texts]

    class MockPresentation:
        def __init__(self):
            self.slides = [
                MockSlide(["Title"]),
                MockSlide(["Content"])
            ]

    mock_image = MagicMock()
    mock_draw = MagicMock()

    # Mock the pptx module
    mock_pptx = Mock()
    mock_pptx.Presentation = lambda _: MockPresentation()
    monkeypatch.setattr("sys.modules", {"pptx": mock_pptx, **sys.modules})
    
    setup_logging()
    caplog.set_level(logging.INFO)

    # Create a test PowerPoint document
    test_ppt = tmp_path / "test.pptx"
    test_ppt.write_bytes(b"Mock PPT content")
    
    # Convert the document
    with patch("PIL.Image.new", return_value=mock_image), \
         patch("PIL.ImageDraw.Draw", return_value=mock_draw), \
         patch('sys.argv', ['file2ai.py', 'convert', '--input', str(test_ppt), '--format', 'image']):
        args = parse_args()
        convert_document(args)
    
    # Check that image operations were called
    assert mock_image.save.called
    assert mock_draw.text.called
    assert "Successfully converted PowerPoint to images" in caplog.text

    # Clean up
    shutil.rmtree(Path("exports"))




def test_ppt_conversion_errors(tmp_path, caplog, monkeypatch):
    """Test error handling in PowerPoint document conversion."""
    import logging
    import sys
    from unittest.mock import Mock, patch, MagicMock

    setup_logging()
    caplog.set_level(logging.ERROR)

    # Create a test PowerPoint document
    test_ppt = tmp_path / "test.pptx"
    test_ppt.write_bytes(b"Mock PPT content")

    # Mock the pptx module
    mock_pptx = Mock()
    monkeypatch.setattr("sys.modules", {"pptx": mock_pptx, **sys.modules})

    # Test missing pptx dependency
    with patch("file2ai.check_pptx_support", return_value=False), \
         patch("file2ai.install_pptx_support", return_value=False):
        with pytest.raises(SystemExit):
            with patch('sys.argv', ['file2ai.py', 'convert', '--input', str(test_ppt), '--format', 'text']):
                args = parse_args()
                convert_document(args)
    
    assert "Failed to install PowerPoint document support" in caplog.text
    caplog.clear()

    # Test missing Pillow for image conversion
    with patch("file2ai.check_pptx_support", return_value=True), \
         patch("file2ai.check_package_support", return_value=False), \
         patch("file2ai.install_package_support", return_value=False):
        with pytest.raises(SystemExit):
            with patch('sys.argv', ['file2ai.py', 'convert', '--input', str(test_ppt), '--format', 'image']):
                args = parse_args()
                convert_document(args)
    
    assert "Failed to install image support" in caplog.text
    caplog.clear()

    # Test unsupported format
    with patch("file2ai.check_pptx_support", return_value=True):
        with pytest.raises(SystemExit):
            with patch('sys.argv', ['file2ai.py', 'convert', '--input', str(test_ppt), '--format', 'pdf']):
                args = parse_args()
                convert_document(args)
    
    assert "PDF conversion requires additional system dependencies" in caplog.text

def test_html_dependency_management(monkeypatch, caplog):
    """Test beautifulsoup4 dependency checking and installation."""
    import logging
    from importlib.util import find_spec
    
    # Mock importlib.util.find_spec to simulate missing bs4
    def mock_find_spec(name):
        return None if name == "bs4" else find_spec(name)
    
    monkeypatch.setattr(importlib.util, "find_spec", mock_find_spec)
    
    # Mock successful pip install
    def mock_check_call(*args, **kwargs):
        return 0
    monkeypatch.setattr(subprocess, "check_call", mock_check_call)
    
    # Test dependency checking
    assert check_html_support() is False
    
    # Test installation
    assert install_html_support() is True

def test_html_to_text_conversion(tmp_path, caplog):
    """Test HTML to text conversion."""
    import logging
    
    # Create a test HTML file
    test_html = """<!DOCTYPE html>
<html>
<head><title>Test Document</title></head>
<body>
    <h1>Test Heading</h1>
    <p>Test paragraph</p>
    <ul><li>List item</li></ul>
    <table><tr><td>Cell</td></tr></table>
</body>
</html>"""
    
    test_file = tmp_path / "test.html"
    test_file.write_text(test_html)
    
    # Set up arguments for conversion
    with patch('sys.argv', ['file2ai.py', 'convert', '--input', str(test_file), '--format', 'text']):
        args = parse_args()
        convert_document(args)
    
    # Check output file
    exports_dir = Path("exports")
    output_files = list(exports_dir.glob("test*.text"))
    assert len(output_files) == 1
    output_content = output_files[0].read_text()
    
    # Verify content structure is preserved
    assert "Test Document" in output_content
    assert "Test Heading" in output_content
    assert "Test paragraph" in output_content
    assert "List item" in output_content
    assert "Cell" in output_content
    
    # Clean up
    shutil.rmtree(exports_dir)

def test_html_to_pdf_conversion(tmp_path, caplog):
    """Test HTML to PDF conversion."""
    import logging
    
    # Create a test HTML file with an image
    test_html = """<!DOCTYPE html>
<html>
<head><title>Test Document</title></head>
<body>
    <h1>Test Heading</h1>
    <img src="test.png" alt="Test Image">
</body>
</html>"""
    
    test_file = tmp_path / "test.html"
    test_file.write_text(test_html)
    
    # Create a test image
    test_image = tmp_path / "test.png"
    from PIL import Image
    img = Image.new('RGB', (100, 100), color='red')
    img.save(test_image)
    
    # Mock weasyprint for PDF generation
    mock_pdf = b"%PDF-1.4 test pdf content"
    mock_weasyprint = MagicMock()
    mock_weasyprint.HTML.return_value.write_pdf.return_value = mock_pdf
    mock_weasyprint.__spec__ = MagicMock(name='weasyprint.__spec__')
    
    # Create PIL mock with Image attribute and spec
    mock_pil = MagicMock()
    mock_pil.Image = MagicMock()
    mock_pil.__spec__ = MagicMock(name='PIL.__spec__')
    
    with patch.dict('sys.modules', {
            'weasyprint': mock_weasyprint,
            'PIL': mock_pil
        }):
        with patch('sys.argv', ['file2ai.py', 'convert', '--input', str(test_file), '--format', 'pdf']):
            args = parse_args()
            convert_document(args)
    
    # Check output file
    exports_dir = Path("exports")
    output_files = list(exports_dir.glob("test*.pdf"))
    assert len(output_files) == 1
    assert output_files[0].read_bytes() == mock_pdf
    
    # Clean up
    shutil.rmtree(exports_dir)

def test_html_to_image_conversion(tmp_path, caplog):
    """Test HTML to image conversion."""
    import logging
    
    # Create a test HTML file
    test_html = """<!DOCTYPE html>
<html>
<head><title>Test Document</title></head>
<body><h1>Test Heading</h1></body>
</html>"""
    
    test_file = tmp_path / "test.html"
    test_file.write_text(test_html)
    
    # Mock PDF generation
    mock_pdf = b"%PDF-1.4 test pdf content"
    mock_weasyprint = MagicMock()
    mock_weasyprint.HTML.return_value.write_pdf.return_value = mock_pdf
    mock_weasyprint.__spec__ = MagicMock(name='weasyprint.__spec__')
    
    # Mock PyMuPDF document
    mock_doc = MagicMock()
    mock_doc.__len__.return_value = 2  # Two pages
    mock_fitz = MagicMock()
    mock_fitz.open.return_value = mock_doc
    mock_fitz.__spec__ = MagicMock(name='fitz.__spec__')
    
    # Create PIL mock with Image attribute and spec
    mock_pil = MagicMock()
    mock_pil.Image = MagicMock()
    mock_pil.__spec__ = MagicMock(name='PIL.__spec__')
    
    with patch.dict('sys.modules', {
            'weasyprint': mock_weasyprint,
            'fitz': mock_fitz,
            'PIL': mock_pil
        }):
        with patch('sys.argv', ['file2ai.py', 'convert', '--input', str(test_file), '--format', 'image']):
            args = parse_args()
            convert_document(args)
    
    # Check output files
    exports_dir = Path("exports")
    images_dir = exports_dir / "images"
    
    # Verify image files exist
    assert (images_dir / "test_page_1.png").exists()
    assert (images_dir / "test_page_2.png").exists()
    
    # Verify the list file exists and contains correct paths
    list_files = list(exports_dir.glob("test*.image"))
    assert len(list_files) == 1
    content = list_files[0].read_text()
    assert "exports/images/test_page_1.png" in content
    assert "exports/images/test_page_2.png" in content
    
    # Clean up
    shutil.rmtree(exports_dir)

def test_mhtml_conversion(tmp_path, caplog):
    """Test MHTML file conversion."""
    import logging
    
    # Create a test MHTML file
    mhtml_content = """From: <Saved by file2ai>
Subject: Test MHTML Document
Date: Thu, 01 Jan 2024 00:00:00 +0000
MIME-Version: 1.0
Content-Type: multipart/related;
    boundary="----=_NextPart_000"

------=_NextPart_000
Content-Type: text/html; charset="utf-8"

<!DOCTYPE html>
<html>
<head><title>MHTML Test</title></head>
<body><h1>Test Content</h1></body>
</html>
------=_NextPart_000--"""
    
    test_file = tmp_path / "test.mhtml"
    test_file.write_text(mhtml_content)
    
    with patch('sys.argv', ['file2ai.py', 'convert', '--input', str(test_file), '--format', 'text']):
        args = parse_args()
        convert_document(args)
    
    # Check output file
    exports_dir = Path("exports")
    output_files = list(exports_dir.glob("test*.text"))
    assert len(output_files) == 1
    content = output_files[0].read_text()
    
    # Verify content
    assert "MHTML Test" in content
    assert "Test Content" in content
    
    # Clean up
    shutil.rmtree(exports_dir)

def test_html_conversion_errors(tmp_path, caplog):
    """Test HTML conversion error handling."""
    import logging
    
    # Create a test HTML file
    test_file = tmp_path / "test.html"
    test_file.write_text("<html><body>Test</body></html>")
    
    # Test missing beautifulsoup4
    with patch("file2ai.check_html_support", return_value=False), \
         patch("file2ai.install_html_support", return_value=False), \
         pytest.raises(SystemExit), \
         patch('sys.argv', ['file2ai.py', 'convert', '--input', str(test_file), '--format', 'text']):
        args = parse_args()
        convert_document(args)
    assert "Failed to install HTML document support" in caplog.text
    
    # Test missing weasyprint for PDF
    with patch("file2ai.check_html_support", return_value=True), \
         patch("file2ai.check_package_support", return_value=False), \
         patch("file2ai.install_package_support", return_value=False), \
         pytest.raises(SystemExit), \
         patch('sys.argv', ['file2ai.py', 'convert', '--input', str(test_file), '--format', 'pdf']):
        args = parse_args()
        convert_document(args)
    assert "Failed to install PDF conversion support" in caplog.text
    
    # Test missing PyMuPDF for image conversion
    with patch("file2ai.check_html_support", return_value=True), \
         patch("file2ai.check_package_support", side_effect=[True, False]), \
         patch("file2ai.install_package_support", return_value=False), \
         pytest.raises(SystemExit), \
         patch('sys.argv', ['file2ai.py', 'convert', '--input', str(test_file), '--format', 'image']):
        args = parse_args()
        convert_document(args)
    assert "Failed to install PDF conversion support" in caplog.text
